\chapter{Parcial 1}


\section{Sobre esta guía}\index{Sobre la guía}

La siguiente guía tiene como objetivo presentar de manera sistemática los contenidos teórico práctico de la asignatura \textbf{Programación de aplicaciones web} en base al plan de carrera del Instituto Tecnológico Benito Juárez en su rediseño del año 2016 para Desarrollo de Software.

\begin{center}
	Datos generales de la asignatura\\
		\begin{tabular}{ |c|c| } 
			\hline
			Nombre de la asignatura: & Programación Aplicaciones Web \\
			\hline
			Campo de formación: & Adaptación tecnológica e innovación \\ 
			\hline
			Unidad de organización curricular: & Formación técnica profesional \\
			\hline
			Número de período académico: & 4 \\
			\hline
			Número de horas de la asignatura: & 122 \\
			\hline
			Número de horas por cada componente: & 
			\begin{tabular}{c}
				Docencia: 60\\
				Prácticas de aprendizaje: 24 \\ 
				Aprendizaje autónomo: 38 \\
			\end{tabular} \\
			\hline
			Docente: & Freddy Heredia: \textbf{\texttt{fheredia@yavirac.edu.ec}}\\
			\hline
		\end{tabular}
\end{center}

\section{El origen} \index{El origen}

\cite{sl}Aunque los inicios de Internet se remontan a los años setenta, no ha sido hasta los años noventa cuando, gracias a la Web, se ha extendido su uso por todo el mundo. En pocos años la Web ha evolucionado enormemente: se ha pasado de páginas sencillas, con pocas imágenes y contenidos estáticos a páginas complejas con contenidos dinámicos que provienen de bases de datos, lo que permite la creación de "aplicaciones web".
\\\\
\cite{sl}Internet y la Web han incluido enormemente tanto en el mundo de la informática
como en la sociedad en general. Si nos centramos en la Web, en poco menos de 10
años ha transformado los sistemas informáticos: ha roto las barreras físicas (debido a
la distancia), económicas y lógicas (debido al empleo de distintos sistemas operativos,
protocolos, etc.) y ha abierto todo un abanico de nuevas posibilidades. Una de las áreas
que más expansión está teniendo en la Web en los últimos años son las aplicaciones
web.
\\\\
\cite{sl}Las aplicaciones web permiten la generación automática de contenido, la creación
de páginas personalizadas según el perfil del usuario o el desarrollo del comercio electrónico. Además, una aplicación web permite interactuar con los sistemas informáticos de gestión de una empresa, como puede ser gestión de clientes, contabilidad o
inventario, a través de una página web.
\\\\
\cite{sl}De forma breve, una aplicación web se puede definir como una aplicación en la cual el usuario por medio de un navegador realiza peticiones a una aplicación remota accesible a través de internet (o a través de una Intranet) y que recibe una respuesta que se muestra en el propio navegador.

\begin{remark}
	\url{https://rua.ua.es/dspace/bitstream/10045/16995/1/sergio_lujan-programacion_de_aplicaciones_web.pdf}
\end{remark}


\subsection{Protocolos de internet} \index{Protocolos de internet}
El éxito de Internet se basa mucho en el empleo de TCP/IP, el conjunto de protocolos de comunicación que permiten el intercambio de información de forma independiente de los sistemas en que ésta se encuentra almacenada. TCP/IP constituye
la solución problema de heterogeneidad de los sistemas informáticos. El 1 de enero de
1983, TCP/IP se estableció como el protocolo estándar de comunicación en Internet.\\
El conjunto de protocolos TCP/IP, también llamado la pila de protocolos
TCP/IP, incluye una serie de protocolos que se encuentran en el nivel 7 o de aplicación de la arquitectura Open System Interconnection (OSI) y que proporcionan una
serie de servicios.\\
Como un mismo ordenador puede atender varios servicios, cada servicio se identifica con un número llamado puerto. Por tanto, a cada protocolo le corresponde un
número de puerto. Los protocolos que se encuentran estandarizados poseen un puerto
reservado que no puede emplear ningún otro protocolo.

En el siguiente cuadro se muestran los protocolos del nivel 7 más comunes de Internet
junto con el número de puerto que emplean.

\cite{osi}En la siguiente imagen se muestran las capas del modelo OSI:

\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{osi.png}
	\caption{Modelo OSI}
	\label{fig:super}
\end{figure}

\begin{remark}
Véa el siguiente vídeo: Guerreros de la red \\
\url{https://youtu.be/1c2U1R8XXvA}
\end{remark}
\section{Arquitecturas cliente/servidor} \index{Arquitectura cliente/servidor}

\cite{sl}Las aplicaciones web son un tipo especial de aplicaciones cliente/servidor. Antes de
aprender a programar aplicaciones web conviene conocer las características básicas de las
arquitecturas cliente/servidor.

Cliente/servidor es una arquitectura de red
en la que cada ordenador o proceso en
la red es cliente o servidor
. Normalmente, los servidores son ordenadores potentes
dedicados a gestionar unidades de disco (servidor de ficheros), impresoras (servidor de impresoras), tráco de red (servidor de red), datos (servidor de bases de datos) o
incluso aplicaciones (servidor de aplicaciones), mientras que los clientes son máquinas
menos potentes y usan los recursos que ofrecen los servidores.

Esta arquitectura implica la existencia de una relación entre procesos que solicitan
servicios (clientes) y procesos que responden a estos servicios (servidores). Estos
dos tipos de procesos pueden ejecutarse en el mismo procesador o en distintos.

La arquitectura cliente/servidor permite la creación de aplicaciones distribuidas.
La principal ventaja de esta arquitectura es que facilita la separación de las funciones
según su servicio, permitiendo situar cada función en la plataforma más adecuada
para su ejecución. Además, también presenta las siguientes ventajas:
\begin{itemize}
	\item Las redes de ordenadores permiten que múltiples procesadores puedan ejecutar
	partes distribuidas de una misma aplicación, logrando concurrencia de procesos.
	\item Existe la posibilidad de migrar aplicaciones de un procesador a otro con modificaciones mínimas en los programas.
	\item Se obtiene una escalabilidad de la aplicación. Permite la ampliación horizontal
	o vertical de las aplicaciones. La \textbf{escalabilidad horizontal} se refiere a la capacidad de añadir o suprimir estaciones de trabajo que hagan uso de la aplicación
	(clientes), sin que afecte sustancialmente al rendimiento general, La \textbf{escalabilidad vertical} se refiere a la capacidad de migrar hacia servidores
	de mayor capacidad o velocidad, o de un tipo distinto de arquitectura sin que
	afecte a los clientes.
	\item Posibilita el acceso a los datos independientemente de donde se encuentre el
usuario.
\end{itemize}	

\subsection{Separación de funciones}\index{Separación de funciones}

La arquitectura cliente/servidor nos permite la separación de funciones en tres
niveles:

\begin{itemize}
\item \textbf{Lógica de presentación}. Se encarga de la entrada y salida de la aplicación con
el usuario. Sus principales tareas son: obtener información del usuario, enviar la
información del usuario a la lógica de negocio para su procesamiento, recibir los
resultados del procesamiento de la lógica de negocio y presentar estos resultados
al usuario.

\item \textbf{Lógica de negocio (o aplicación).} Se encarga de gestionar los datos a nivel
de procesamiento. Actúa de puente entre el usuario y los datos. Sus principales
tareas son: recibir la entrada del nivel de presentación, interactuar con la lógica
de datos para ejecutar las reglas de negocio (business rules) que tiene que cumplir la aplicación (facturación, cálculo de nóminas, control de inventario, etc.) y
enviar el resultado del procesamiento al nivel de presentación.


\item \textbf{Lógica de datos.} Se encarga de gestionar los datos a nivel de almacenamiento.
Sus principales tareas son: almacenar los datos, recuperar los datos, mantener
los datos y asegurar la integridad de los datos.
\end{itemize}	

\begin{figure}[H]
	\center
	\includegraphics[width=1\textwidth]{arquitectura-cliente-servidor.png}
	\caption{Arquitectura cliente/servidor}
	\label{fig:super}
\end{figure}

\subsection{El cliente}
\cite{mdn}El cliente es cualquier herramienta que actué en representación del usuario para solicitar a
un servidor web el envío de los recursos que desea obtener mediante HTTP. Esta función es realizada en la mayor parte de los casos por un navegador Web. Hay excepciones, como el caso de programas específicamente usados por desarrolladores para desarrollar y depurar sus aplicaciones. 
\\
El navegador es siempre el que inicia una comunicación (petición), y el servidor nunca la comienza (hay algunos mecanismos que permiten esto, pero no son muy habituales).  
\\
Para poder mostrar una página Web, el navegador envía una petición de documento HTML al servidor. Entonces procesa este documento, y envía más peticiones para solicitar scripts, hojas de estilo (CSS), y otros datos que necesite (normalmente vídeos y/o imágenes). El navegador, une todos estos documentos y datos, y compone el resultado final: la página Web. Los scripts, los ejecuta también el navegador, y también pueden generar más peticiones de datos en el tiempo, y el navegador, gestionará y actualizará la página Web en consecuencia. 
\\
Una página Web, es un documento de hipertexto (HTTP), luego habrá partes del texto en la página que puedan ser enlaces (links) que pueden ser activados (normalmente al hacer click sobre ellos) para hacer una petición de una nueva página Web, permitiendo así dirigir su agente de usuario y navegar por la Web. El navegador, traduce esas direcciones en peticiones de HTTP, e interpretara y procesará las respuestas HTTP, para presentar al usuario la página Web que desea.
\\
La parte cliente de las aplicaciones web suele estar formada por el código HTML
que forma la página web más algo de código ejecutable realizado en lenguaje de script
del navegador (JavaScript o VBScript) o mediante pequeños programas (applets) realizados en Java. También se solían emplear plugins que permiten visualizar otros
contenidos multimedia (como Macromedia Flash
), aunque no se encuentran tan extendidos como las tecnologías anteriores y plantean problemas de incompatibilidad
entre distintas plataformas. Por tanto, la misión del cliente web es interpretar las
páginas HTML y los diferentes recursos que contienen (imágenes, sonidos, etc.).
\\
Las tecnologías que se suelen emplear para programar el cliente web son:

\begin{itemize}
	\item HTML
	\item CSS
	\item Javascript
\end{itemize}
\begin{remark}
	Cada tecnología puede tener sus variantes.\\
	WebAssembly es un proyecto prometedor.\\
	Algunas tecnologías ya están en desuso (Applets, Flash entre otras.)
\end{remark}

\subsection{El servidor}
Al otro lado del canal de comunicación, está el servidor, el cual "sirve" los datos que ha pedido el cliente. Un servidor conceptualmente es una unica entidad, aunque puede estar formado por varios elementos, que se reparten la carga de peticiones, (load balancing), u otros programas, que gestionan otros computadores (como cache, bases de datos, servidores de correo electrónico, ...), y que generan parte o todo el documento que ha sido pedido. 
\\
Un servidor no tiene que ser necesariamente un único equipo físico, aunque si que varios servidores pueden estar funcionando en un único computador. En el estándar HTTP/1.1 y Host , pueden incluso compartir la misma dirección de IP.

\subsection{Transferencia de páginas web a través de http}

El proceso completo, desde que el usuario solicita una página, hasta que el cliente
web (navegador) se la muestra con el formato apropiado, es el siguiente:

\begin{enumerate}
	\item El usuario especifica en el cliente web la dirección de la página que desea consultar: el usuario escribe en el navegador la dirección (URL) de la página que
	desea visitar o pulsa un enlace.
	\item El cliente establece una conexión con el servidor web.
	\item El cliente solicita la página o el objeto deseado. 
	\item El servidor envía dicha página u objeto (o, si no existe, devuelve un código de
	error).
	\item Si se trata de una página HTML, el cliente inicia sus labores de interpretación
	de los códigos HTML. Si el cliente web encuentra instrucciones que hacen referencia a otros objetos que se tienen que mostrar con la página (imágenes, sonidos, animaciones multimedia, etc.), establece automáticamente comunicación
	con el servidor web para solicitar dichos objetos.
	\item Se cierra la conexión entre el cliente y el servidor.
	\item Se muestra la página al usuario.
\end{enumerate}

Obsérvese que siempre se libera la conexión, por lo que ésta sólo tiene la duración
correspondiente a la transmisión de la página solicitada. Esto se hace así para no
desperdiciar innecesariamente el ancho de banda de la red mientras el usuario lee la
página recibida.
Cuando el usuario activa un enlace de la página, se establece una nueva conexión
para recibir otra página o elemento multimedia. Por ello, el usuario tiene la sensación
de que está disfrutando de una conexión permanente cuando realmente no es así.
Un detalle importante es que para cada objeto que se transfiere por la red se realiza
una conexión independiente. Por ejemplo, si el cliente web solicita una página que
contiene dos imágenes integradas, se realizan tres conexiones: una para el documento
HTML y dos para los archivos de las imágenes.

Una aplicación web (web-based application) es un tipo especial de aplicación cliente/servidor, donde tanto el cliente (el navegador, explorador o visualizador/browser)
) como
el servidor (el servidor web) y el protocolo mediante el que se comunican (HTTP)
están estandarizados y no han de ser creados por el programador de aplicaciones.
\\
El protocolo HTTP forma parte de la familia de protocolos de comunicaciones
TCP/IP, que son los empleados en Internet. Estos protocolos permiten la conexión
de sistemas heterogéneos, lo que facilita el intercambio de información entre distintos
ordenadores. HTTP se sitúa en el nivel 7 (aplicación) del modelo OSI.

\section{HTTP/HTTPS}

\cite{mdn}Hypertext Transfer Protocol (HTTP) (o Protocolo de Transferencia de Hipertexto en español) es un protocolo de la capa de aplicación para la transmisión de documentos hipermedia, como HTML. Fue diseñado para la comunicación entre los navegadores y servidores web, aunque puede ser utilizado para otros propósitos también. Sigue el clásico modelo cliente-servidor, en el que un cliente establece una conexión, realizando una petición a un servidor y espera una respuesta del mismo. Se trata de un protocolo sin estado, lo que significa que el servidor no guarda ningún dato (estado) entre dos peticiones. Aunque en la mayoría de casos se basa en una conexión del tipo TCP/IP, puede ser usado sobre cualquier capa de transporte segura o de confianza, es decir, sobre cualquier protocolo que no pierda mensajes silenciosamente, tal como UDP.

Clientes y servidores se comunican intercambiando mensajes individuales (en contraposición a las comunicaciones que utilizan flujos continuos de datos). Los mensajes que envía el cliente, normalmente un navegador Web, se llaman peticiones, y los mensajes enviados por el servidor se llaman respuestas.

\begin{figure}[H]
	\center
	\includegraphics[width=1\textwidth]{HTTPyCapas.png}
	\caption{HTTP y capas}
	\label{fig:super}
\end{figure}

Diseñado a principios de la década de 1990, HTTP es un protocolo ampliable, que ha ido evolucionando con el tiempo. Es lo que se conoce como un protocolo de la capa de aplicación, y se transmite sobre el protocolo TCP, o el protocolo encriptado TLS (en-US), aunque teóricamente podría usarse cualquier otro protocolo fiable. Gracias a que es un protocolo capaz de ampliarse, se usa no solo para transmitir documentos de hipertexto (HTML), si no que además, se usa para transmitir imágenes o vídeos, o enviar datos o contenido a los servidores, como en el caso de los formularios de datos. HTTP puede incluso ser utilizado para transmitir partes de documentos, y actualizar páginas Web en el acto.

En realidad, hay más elementos intermedios, entre un navegador y el servidor que gestiona su petición: hay otros tipos de dispositivos: como routers, modems ... Es gracias a la arquitectura en capas de la Web, que estos intermediarios, son transparentes al navegador y al servidor, ya que HTTP se apoya en los protocolos de red y transporte. HTTP es un protocolo de aplicación, y por tanto se apoya sobre los anteriores. Aunque para diagnosticar problemas en redes de comunicación, las capas inferiores son irrelevantes para la definición del protocolo HTTP . 

\subsection{Características clave del protocolo HTTP}
\begin{itemize}
	\item \textbf{HTTP es sencillo}: HTTP esta pensado y desarrollado para ser leído y fácilmente interpretado por las personas, haciendo de esta manera más facil la depuración de errores, y reduciendo la curva de aprendizaje para las personan que empieza a trabajar con él.
	\item \textbf{HTTP es extensible}: Presentadas en la versión HTTP/1.0, las cabeceras de HTTP, han hecho que este protocolo sea fácil de ampliar y de experimentar con él. Funcionalidades nuevas pueden desarrollarse, sin más que un cliente y su servidor, comprendan la misma semántica sobre las cabeceras de HTTP.
	\item \textbf{HTTP es un protocolo con sesiones, pero sin estados}: HTTP es un protocolo sin estado, es decir: no guarda ningún dato entre dos peticiones en la mísma sesión. Esto crea problemáticas, en caso de que los usuarios requieran interactuar con determinadas páginas Web de forma ordenada y coherente, por ejemplo, para el uso de "cestas de la compra" en páginas que utilizan en comercio electrónico. Pero, mientras HTTP ciertamente es un protocolo sin estado, el uso de HTTP cookies, si permite guardar datos con respecto a la sesión de comunicación. Usando la capacidad de ampliación del protocolo HTTP, las cookies permiten crear un contexto común para cada sesión de comunicación.
	\item \textbf{HTTP y conexiones:} Una conexión se gestiona al nivel de la capa de trasporte, y por tanto queda fuera del alcance del protocolo HTTP. Aún con este factor, HTTP no necesita que el protocolo que lo sustenta mantenga una conexión continua entre los participantes en la comunicación, solamente necesita que sea un protocolo fiable o que no pierda mensajes (como mínimo, en todo caso, un protocolo que sea capaz de detectar que se ha pedido un mensaje y reporte un error). De los dos protocolos más comunes en Internet, TCP es fiable, mientras que UDP, no lo es. Por lo tanto HTTP, se apoya en el uso del protocolo TCP, que está orientado a conexión, aunque una conexión continua no es necesaria siempre. \\
	Todavía hoy se sigue investigando y desarrollando para conseguir un protocolo de transporte más conveniente para el HTTP. Por ejemplo, Google está experimentado con QUIC, que se apoya en el protocolo UDP y presenta mejoras en la fiabilidad y eficiencia de la comunicación. 
\end{itemize}
\subsection{¿Qué se puede controlar con HTTP?}
Se presenta a continuación una lista con los elementos que se pueden controlar con el protocolo HTTP:
\begin{itemize}
	\item \textbf{Cache}: El como se almacenan los documentos en la caché, puede ser especificado por HTTP. El servidor puede indicar a los proxies y clientes, que quiere almacenar y durante cuanto tiempo. Aunque el cliente, también puede indicar a los proxies de caché intermedios que ignoren el documento almacenado.
	\item \textbf{Flexibilidad del requisito de origen} Para prevenir invasiones de la privacidad de los usuarios, los navegadores Web, solamente permiten a páginas del mismo origen, compartir la información o datos. Esto es una complicación para el servidor, asi que mediante cabeceras HTTP, se puede flexibilizar o relajar esta división entre cliente y servidor
	\item \textbf{Autentificación} Hay páginas Web, que pueden estar protegidas, de manera que solo los usuarios autorizados puedan acceder. HTTP provee de servicios básicos de autentificación, por ejemplo mediante el uso de cabeceras como:  WWW-Authenticate, o estableciendo una sesión especifica mediante el uso de  HTTP cookies. 
	\item \textbf{Proxies y  tunneling} Servidores y/o clientes pueden estar en intranets y esconder así su verdadera dirección IP a otros. Las peticiones HTTP utilizan los proxies para acceder a ellos. Pero no todos los proxies son HTTP proxies. El protocolo SOCKS, por ejemplo, opera a un nivel más bajo. Otros protocolos, como el FTP, pueden ser servidos mediante estos proxies.
	\item \textbf{Sesiones} El uso de HTTP cookies permite relacionar peticiones con el estado del servidor. Esto define las sesiones, a pesar de que por definición el protocolo HTTP es un protocolo sin estado. Esto es muy útil no sólo para aplicaciones de comercio electrónico, sino también para cualquier sitio que permita configuración al usuario.
\end{itemize}

\subsection{Mensajes HTTP}
Existen dos tipos de mensajes HTTP: peticiones y respuestas, cada uno sigue su propio formato.

Las peticiones y respuestas HTTP, comparten una estructura similar, compuesta de:

\begin{itemize}
\item Una línea de inicio ('start-line' en inglés) describiendo la petición a ser implementada, o su estado, sea de éxito o fracaso. Esta línea de comienzo, es siempre una única línea.
\item Un grupo opcional de cabeceras HTTP, indicando la petición o describiendo el cuerpo ('body' en inglés) que se incluye en el mensaje. 
\item Una línea vacía ('empty-line' en inglés) indicando toda la meta-información ha sido enviada.
\item Un campo de cuerpo de mensaje opcional ('body' en inglés) que lleva los datos asociados con la petición (como contenido de un formulario HTML), o los archivos o documentos asociados a una respuesta (como una página HTML, o un archivo de audio, vídeo ... ) . La presencia del cuerpo y su tamaño es indicada en la línea de inicio y las cabeceras HTTP.

\end{itemize}
La línea de inicio y las cabeceras HTTP, del mensaje, son conocidas como la cabeza de la peticiones, mientras que su contenido en datos se conoce como el cuerpo del mensaje.

\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{HTTPMsgStructure2.png}
	\caption{Mensajes}
	\label{fig:super}
\end{figure}

\subsubsection{Cabeceras}

Las cabeceras HTTP  de una petición siguen la misma estructura que la de una cabecera HTTP. Una cadena de caracteres, que no diferencia mayusculas ni minusculas, seguida por dos puntos  (':')  y un valor cuya estructura depende de la cabecera. La cabecera completa, incluido el valor, ha de ser formada en una única línea, y pude ser bastante larga. 

Hay bastantes cabeceras posibles. Estas se pueden clasificar en varios grupos: 
\begin{itemize}
	\item Cabeceras generales, ('General headers' en inglés), como Via (en-US),  afectan al mensaje como una unidad completa.
	\item Cabeceras de petición, ('Request headers' en inglés), como User-Agent, Accept-Type, modifican la petición especificándola en mayor detalle ( como: Accept-Language (en-US), o dándole un contexto, como:  Referer, o restringiéndola condicionalmente, como: If-None.
	\item Cabeceras de entidad, ('Entity headers' en ingles), como Content-Length las cuales se aplican al cuerpo de la petición. Por supuesto, esta cabecera no necesita ser transmitida si el mensaje no tiene cuerpo ('body' en inglés). 
\end{itemize}

\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{HTTP_Request_Headers2.png}
	\caption{Cabeceras}
	\label{fig:super}
\end{figure}

\subsubsection{Cuerpo}
La parte final de la petición el el cuerpo. No todas las peticiones llevan uno: las peticiones que reclaman datos, como GET, HEAD, DELETE, o OPTIONS, normalmente, no necesitan ningún cuerpo. Algunas peticiones pueden mandar peticiones al servidor con el fin de actualizarlo: como es el caso con la petición POST  (que contiene datos de un formulario HTML). 
\\
Los cuerpos pueden ser dividos en dos categorias:
\begin{itemize}
	\item Cuerpos con un único dato, que consisten en un único archivo defindo por las dos cabeceras: Content-Type y Content-Length.  
	\item Cuerpos con múltiples datos, que están formados por distintos contenidos, normalmente estan asociados con los formularios HTML. 
\end{itemize}

\subsubsection{Peticiones}
Un ejemplo de petición HTTP:

\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{HTTP_Request.png}
	\caption{Petición}
	\label{fig:super}
\end{figure}
Una petición de HTTP, está formado  por los siguientes campos:

\begin{itemize}
	\item Un método HTTP,  normalmente pueden ser un verbo, como: GET, POST o un nombre como: OPTIONS (en-US) o HEAD (en-US), que defina la operación que el cliente quiera realizar. El objetivo de un cliente, suele ser una petición de recursos, usando GET, o presentar un valor de un formulario HTML, usando POST, aunque en otras ocasiones puede hacer otros tipos de peticiones. 
	\item La dirección del recurso pedido; la URL del recurso, sin los elementos obvios por el contexto, como pueden ser: sin el  protocolo (http://),  el dominio (aquí developer.mozilla.org), o el puerto TCP (aquí el 80). 
	\item La versión del protocolo HTTP.
	\item Cabeceras HTTP opcionales, que pueden aportar información adicional a los servidores.
	\item O un cuerpo de mensaje, en algún método, como puede ser POST, en el cual envía la información para el servidor.
\end{itemize}

\subsubsection{Respuestas}
Un ejemplo de repuesta:
\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{HTTP_Response.png}
	\caption{Respuesta}
	\label{fig:super}
\end{figure}
Las respuestas están formadas por los siguentes campos:

\begin{itemize}
	\item La versión del protocolo HTTP que están usando.
	\item Un código de estado, indicando si la petición ha sido exitosa, o no, y debido a que. Códigos de estado muy comunes son:  200, 404, o 302
	\item Un mensaje de estado, una breve descripción del código de estado. 
	\item Cabeceras HTTP, como las de las peticiones.
	\item Opcionalmente, el recurso que se ha pedido.
\end{itemize}

\subsection{Métodos de petición HTTP}

HTTP define un conjunto de métodos de petición para indicar la acción que se desea realizar para un recurso determinado. Aunque estos también pueden ser sustantivos, estos métodos de solicitud a veces son llamados HTTP verbs. Cada uno de ellos implementan una semántica diferente, pero algunas características similares son compartidas por un grupo de ellos: ej. un request method puede ser safe, idempotent (en-US), o cacheable.

\subsubsection{GET}
El método GET  solicita una representación de un recurso específico. Las peticiones que usan el método GET sólo deben recuperar datos.

\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{get.png}
	\caption{GET}
	\label{fig:super}
\end{figure}

\subsubsection{HEAD}
El método HEAD pide una respuesta idéntica a la de una petición GET, pero sin el cuerpo de la respuesta.

\subsubsection{POST}
El método POST se utiliza para enviar una entidad a un recurso en específico, causando a menudo un cambio en el estado o efectos secundarios en el servidor. \\
El tipo de cuerpo de la solicitud se indica mediante el encabezado Content-Type.

\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{post.png}
	\caption{POST}
	\label{fig:super}
\end{figure}

\subsubsection{PUT}
El método de solicitud HTTP PUT crea un nuevo recurso o reemplaza una representación del recurso de destino con la carga útil de la solicitud.

La diferencia entre PUT y POST es que PUT es idempotente: llamarlo una o varias veces sucesivamente tiene el mismo efecto (eso no es un efecto secundario), mientras que las sucesivas solicitudes POST idénticas pueden tener efectos adicionales, como realizar un pedido varias veces.
\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{put.png}
	\caption{PUT}
	\label{fig:super}
\end{figure}

\subsubsection{DELETE}
El método DELETE borra un recurso en específico.
\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{delete.png}
	\caption{DELETE}
	\label{fig:super}
\end{figure}

\subsubsection{PATCH}
El método PATCH  es utilizado para aplicar modificaciones parciales a un recurso.\\
PATCH es algo análogo al concepto de "actualización" que se encuentra en CRUD (en general, HTTP es diferente a CRUD y no se deben confundir los dos).
\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{patch.png}
	\caption{PATHC}
	\label{fig:super}
\end{figure}


\begin{remark}
Un método HTTP es seguro si no altera el estado del servidor. En otras palabras, un método es seguro si conduce a una operación de solo lectura. Varios métodos HTTP comunes son seguros: GET, HEAD u OPTIONS. Todos los métodos seguros también son idempotentes, pero no todos los métodos idempotentes son seguros. Por ejemplo, PUT y DELETE son idempotentes pero inseguros.
\end{remark}

\begin{remark}
Una respuesta almacenable en caché es una respuesta HTTP que se puede almacenar en caché, que se almacena para recuperarla y usarla más tarde, guardando una nueva solicitud en el servidor. No todas las respuestas HTTP se pueden almacenar en caché
\end{remark}

\begin{remark}
Un método HTTP es idempotente si se puede realizar una solicitud idéntica una o varias veces seguidas con el mismo efecto y dejando el servidor en el mismo estado. En otras palabras, un método idempotente no debería tener efectos secundarios (excepto para llevar estadísticas). Implementados correctamente, los métodos GET, HEAD, PUT y DELETE son idempotentes, pero no el método POST. Todos los métodos seguros también son idempotentes.
\end{remark}

\subsection{HTTP response status codes}

Los códigos de estado de respuesta HTTP indican si una solicitud HTTP específica se completó con éxito. Las respuestas se agrupan en cinco clases:

\begin{enumerate}
	\item Respuestas informativas (100–199)
	\item Respuestas exitosas (200–299)
	\item Mensajes de redirección (300–399)
	\item Respuestas de error del cliente (400–499)
	\item Respuestas de error del servidor (500–599)
\end{enumerate}

\subsubsection{Respuestas informativas }

\begin{itemize}
	\item 100 Continue: indica que todo está bien hasta el momento y que el cliente debe continuar con la solicitud o ignorarla si ya finalizó.
	\item 101 Protocolos de conmutación: este código se envía en respuesta a un encabezado de solicitud de actualización del cliente e indica el protocolo al que se está cambiando el servidor.
	\item 102 Procesamiento (WebDAV): Este código indica que el servidor ha recibido y está procesando la solicitud, pero aún no hay respuesta disponible.
\end{itemize}

\subsection{URL - URI}


La «Uniform Resource Locator» (URL o Localizadora Uniforme de Recursos en Español) es una cadena de texto que especifica dónde se puede encontrar un recurso (como una página web, una imagen o un video) en Internet.

En el contexto de HTTP, las URLs se denominan "dirección web" o "enlace". Tu navegador muestra las URLs en su barra de direcciones, por ejemplo: https://developer.mozilla.org — Algunos navegadores muestran solo la parte de una URL después de "//", es decir, el Nombre de dominio.

Las URLs también se pueden utilizar para la transferencia de archivos (FTP), correos electrónicos (SMTP) y otras aplicaciones.

Un URI (Identificador Uniforme de Recursos de sus siglas en inglés: Uniform Resource Identifier) es una cadena que se refiere a un recurso. Los más comunes son URLs, que identifican el recurso dando su ubicación en la Web. URNs (en-US), por el contrario, se refiere a un recurso por un nombre, en un espacio de nombres determinados, como el ISBN(International Standard Book Number) de un libro.

\url{https://developer.mozilla.org/es/docs/Learn/Common_questions/What_is_a_URL}

\section{Modelo de Objetos de Documento - DOM}

El DOM (Document Object Model en español Modelo de Objetos del Documento) es una API definida para representar e interactuar con cualquier documento HTML o XML. El DOM es un modelo de documento que se carga en el navegador web y que representa el documento como un árbol de nodos, en donde cada nodo representa una parte del documento (puede tratarse de un elemento, una cadena de texto o un comentario).

\begin{remark}
Una Interfaz de Programación de Aplicaciones (API, por sus siglas en inglés) define un conjunto de directivas que pueden ser usadas para tener una pieza de software funcionando con algunas otras.
\end{remark}

El DOM es una de las APIs más usadas en la Web, pues permite ejecutar código en el navegador para acceder e interactuar con cualquier nodo del documento. Estos nodos pueden crearse, moverse o modificarse. Pueden añadirse a estos nodos manejadores de eventos (event listeners en inglés) que se ejecutarán/activarán cuando ocurra el evento indicado en este manejador.

El DOM surgió a partir de la implementación de JavaScript en los navegadores. A esta primera versión también se la conoce como DOM 0 o "Legacy DOM". Hoy en día el grupo WHATWG es el encargado de actualizar el estándar de DOM.


\section{REST}

El término "Transferencia de Estado Representacional" (REST) representa un conjunto de características de diseño de arquitecturas software que aportan confiabilidad, eficiencia y escalibilidad a los sistemas distribuidos. Un sistema es llamado RESTful cuando se ajusta a estas características.

La idea básica de REST es que un recurso, e.j. un documento, es transferido con su estado y su relaciones (hipertexto) mediante formatos y operaciones estandarizadas bien definidas.

Como HTTP, el protocolo estandar de la Web, también transfiere documentos e hipertexto, las APIs HTTP a veces son llamadas APIs RESTful, servicios RESTful, o simplemente servicios REST, aunque no se ajusten del todo a la deficinición de REST. Los principiantes pueden pensar que una API REST es un servicio HTTP que puede ser llamado mediante librerias y herramientas web estandar.

Una API de REST, o API de RESTful, es una interfaz de programación de aplicaciones (API o API web) que se ajusta a los límites de la arquitectura REST y permite la interacción con los servicios web de RESTful. El informático Roy Fielding es el creador de la transferencia de estado representacional (REST).

Las API son conjuntos de definiciones y protocolos que se utilizan para diseñar e integrar el software de las aplicaciones.Suele considerarse como el contrato entre el proveedor de información y el usuario, donde se establece el contenido que se necesita por parte del consumidor (la llamada) y el que requiere el productor (la respuesta).Por ejemplo, el diseño de una API de servicio meteorológico podría requerir que el usuario escribiera un código postal y que el productor diera una respuesta en dos partes: la primera sería la temperatura máxima y la segunda, la mínima.

En otras palabras, las API le permiten interactuar con una computadora o un sistema para obtener datos o ejecutar una función, de manera que el sistema comprenda la solicitud y la cumpla. 

Imagínelas como si fueran los mediadores entre los usuarios o clientes y los recursos o servicios web que quieren obtener. Con ellas, las empresas pueden compartir recursos e información mientras conservan la seguridad, el control y la autenticación, lo cual les permite determinar el contenido al que puede acceder cada usuario. 

Otra ventaja de las API es que usted no necesita saber cómo se recibe el recurso ni de dónde proviene.

REST no es un protocolo ni un estándar, sino más bien un conjunto de límites de arquitectura. Los desarrolladores de las API pueden implementarlo de distintas maneras.

Cuando el cliente envía una solicitud a través de una API de RESTful, esta transfiere una representación del estado del recurso requerido a quien lo haya solicitado o al extremo. La información se entrega por medio de HTTP en uno de estos formatos: JSON (JavaScript Object Notation), HTML, XLT, Python, PHP o texto sin formato. JSON es el lenguaje de programación más popular, ya que tanto las máquinas como las personas lo pueden comprender y no depende de ningún lenguaje, a pesar de que su nombre indique lo contrario. 

También es necesario tener en cuenta otros aspectos. Los encabezados y los parámetros también son importantes en los métodos HTTP de una solicitud HTTP de la API de RESTful, ya que contienen información de identificación importante con respecto a los metadatos, la autorización, el identificador uniforme de recursos (URI), el almacenamiento en caché, las cookies y otros elementos de la solicitud. Hay encabezados de solicitud y de respuesta, pero cada uno tiene sus propios códigos de estado e información de conexión HTTP.

Para que una API se considere de RESTful, debe cumplir los siguientes criterios:

Arquitectura cliente-servidor compuesta de clientes, servidores y recursos, con la gestión de solicitudes a través de HTTP.
Comunicación entre el cliente y el servidor sin estado, lo cual implica que no se almacena la información del cliente entre las solicitudes de GET y que cada una de ellas es independiente y está desconectada del resto.
Datos que pueden almacenarse en caché y optimizan las interacciones entre el cliente y el servidor.
Una interfaz uniforme entre los elementos, para que la información se transfiera de forma estandarizada. Para ello deben cumplirse las siguientes condiciones:
Los recursos solicitados deben ser identificables e independientes de las representaciones enviadas al cliente.
El cliente debe poder manipular los recursos a través de la representación que recibe, ya que esta contiene suficiente información para permitirlo.
Los mensajes autodescriptivos que se envíen al cliente deben contener la información necesaria para describir cómo debe procesarla.
Debe contener hipertexto o hipermedios, lo cual significa que cuando el cliente acceda a algún recurso, debe poder utilizar hipervínculos para buscar las demás acciones que se encuentren disponibles en ese momento.
Un sistema en capas que organiza en jerarquías invisibles para el cliente cada uno de los servidores (los encargados de la seguridad, del equilibrio de carga, etc.) que participan en la recuperación de la información solicitada.
Código disponible según se solicite (opcional), es decir, la capacidad para enviar códigos ejecutables del servidor al cliente cuando se requiera, lo cual amplía las funciones del cliente. 
Si bien la API de REST debe cumplir todos estos parámetros, resulta más fácil de usar que un protocolo definido previamente, como SOAP (protocolo simple de acceso a objetos), el cual tiene requisitos específicos, como la mensajería XML y la seguridad y el cumplimiento integrados de las operaciones, que lo hacen más lento y pesado. 

Por el contrario, REST es un conjunto de pautas que pueden implementarse según sea necesario. Por esta razón, las API de REST son más rápidas y ligeras, cuentan con mayor capacidad de ajuste y, por ende, resultan ideales para el Internet de las cosas (IoT) y el desarrollo de aplicaciones para dispositivos móviles. 

\url{https://www.redhat.com/es/topics/api/what-is-a-rest-api}



\section{Gestor de contenidos}

\cite{mdn}Un sistema de gestión de contenidos o CMS es un programa informático que permite a los usuarios publicar, organizar, cambiar o eliminar diferentes tipos de contenido como texto, imágenes incrustadas, vídeo, audio y código interactivo.

\cite{wiki}Cuenta con una interfaz que controla una o varias bases de datos donde se aloja el contenido del sitio web. El sistema permite manejar de manera independiente el contenido y el diseño. Así, es posible manejar el contenido y darle en cualquier momento un diseño distinto al sitio web sin tener que darle formato al contenido de nuevo, además de permitir la fácil y controlada publicación en el sitio a varios editores. Un ejemplo clásico es el de editores que cargan el contenido al sistema y otro de nivel superior (moderador o administrador) que permite que estos contenidos sean visibles a todo el público (los aprueba).

\subsection{Características de un CMS}
Los sistemas de gestión de contenidos se definen por las siguientes particularidades, muchas de las cuales son, a su vez, grandes ventajas:

\begin{itemize}
	\item Uso intuitivo y fácil para simplificar la edición y publicación de contenidos. No se requieren conocimientos de programación.
	\item Configuración flexible y personalizada a través de múltiples opciones.
	\item Velocidad y rendimiento elevados gracias a su excelente capacidad para el desarrollo de tareas.
	\item Seguridad presente gracias a opciones como aprobación de contenido, verificación de correo electrónico, historial de login o registro de auditoría, entre otras.
	\item Medios de soporte para ayudar a los usuarios a la resolución de dudas y problemas.
\end{itemize}

\begin{figure}[H]
	\center
	\includegraphics[width=1\textwidth]{cms1.png}
	\caption{Algunos sistemas gestores de contenido}
	\label{fig:super}
\end{figure}

\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{cms2.png}
	\caption{Otros sistemas gestores de contenido populares}
	\label{fig:super}
\end{figure}

\section{Entorno de desarrollo}

nodejs
https://github.com/nodesource/distributions/blob/master/README.md

Angular: npm install -g @angular/cli

Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
get-ExecutionPolicy -list

\section{Backend}
\subsection{Postman - Thunder client - curl}
\subsection{Frameworks}
\subsection{Java}
\subsection{Spring boot}
\subsection{Spring data}
\subsection{Postgres - Mongo - Elastic Search}
\subsection{CRUD}
\subsubsection{Entidades - DTOs}
\subsubsection{Repositorios}
\subsubsection{Servicios}
\subsubsection{Controladores}

\section{Frontend}
\subsection{Frameworks}

\cite{wiki}Un entorno de trabajo (del inglés framework), o marco de trabajo es un conjunto estandarizado
de conceptos, prácticas y criterios para enfocar un tipo de problemática particular que sirve como
referencia, para enfrentar y resolver nuevos problemas de índole similar.
En el desarrollo de software, un entorno de trabajo es una estructura conceptual y tecnológica
de asistencia definida, normalmente, con artefactos o módulos concretos de software, que puede
servir de base para la organización y desarrollo de software. Típicamente, puede incluir soporte
de programas, bibliotecas, y un lenguaje interpretado, entre otras herramientas, para así ayudar a
desarrollar y unir los diferentes componentes de un proyecto.
Representa una arquitectura de software que modela las relaciones generales de las entidades del
dominio, y provee una estructura y especial metodología de trabajo, la cual extiende o utiliza las
aplicaciones del dominio.

\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{frontend-frameworks-social.jpg}
	\caption{Algunos frameworks para frontend}
	\label{fig:super}
\end{figure}

\subsection{HTML}


\subsection{CSS}

\cite{mdn}CSS (Cascading Style Sheets - en español Hojas de Estilo en Cascadas) es usado para darle estilo y diseño a las páginas Web — por ejemplo, para cambiar la fuente de letra, color, tamaño y el espaciado de tu contenido; dividir en múltiples columnas, o agregar animaciones y otras propiedades decorativas. Este modulo provee un inicio suave para tu ruta de aprendizaje hacia el dominio de CSS con su funcionamiento básico, como luce su sintaxis, y cómo puedes comenzar a utilizarlo y añadir estilo a HTML.

El CSS se puede usar para estilos de texto muy básicos como, por ejemplo, cambiar el color y el tamaño de los encabezados y los enlaces. Se puede utilizar para crear un diseño, como podría ser convertir una columna de texto en una composición con un área de contenido principal y una barra lateral para información relacionada. Incluso se puede usar para crear efectos de animación.

\subsection{Sintaxis del CSS}
El CSS es un lenguaje basado en reglas: cada usuario define las reglas que especifican los grupos de estilos que van a aplicarse a elementos particulares o grupos de elementos de la página web. Por ejemplo: «Quiero que el encabezado principal de mi página se muestre en letras grandes de color rojo».

El código siguiente muestra una regla CSS muy simple que proporcionaría el estilo descrito en el párrafo anterior:

\begin{lstlisting}
	h1 {
		color: red;
		font-size: 5em;
	}
\end{lstlisting}

La regla se abre con un selector (en-US). Este selecciona el elemento HTML que vamos a diseñar. En este caso, diseñaremos encabezados de nivel uno (<h1> (en-US)).

Luego tenemos un conjunto de llaves { }. Entre estas habrá una o más declaraciones, que tomarán la forma de pares de propiedad y valor. Cada par especifica cada una de las propiedades de los elementos seleccionados y el valor que queremos dar a esa propiedad.

Antes de los dos puntos, tenemos la propiedad; y después, el valor. Las propiedades (en-US) CSS admiten diferentes valores, dependiendo de qué propiedad se esté especificando. En el ejemplo anterior, tenemos la propiedad color, que puede tomar varios valores de color. También tenemos la propiedad de font-size, que puede tomar varias unidades de tamaño como valor.

Una hoja de estilo CSS contendrá muchas de estas reglas, escritas una tras otra.

\begin{lstlisting}
h1 {
	color: red;
	font-size: 5em;
}

p {
	color: black;
}
\end{lstlisting}

Algunos valores se aprenden rápidamente, mientras que otros deberán buscarse. Las páginas de propiedades individuales que hay en el proyecto MDN proporcionan una forma rápida de buscar propiedades y sus valores en caso de olvidarlos o desear saber qué más se puede usar como valor.

\begin{remark}
Nota: Puedes encontrar enlaces a todas las páginas de las propiedades CSS (junto con otras características CSS) enumeradas en la referencia CSS del proyecto MDN. Alternativamente, deberías acostumbrarte a buscar «mdn css-feature-name» en tu motor de búsqueda favorito siempre que necesites obtener más información sobre una función CSS. Por ejemplo, intenta buscar «mdn color» y «mdn font-size».
\end{remark}

\url{https://developer.mozilla.org/es/docs/Web/CSS/Reference}

\subsection{Especificaciones CSS}

Todas las tecnologías de estándares web (HTML, CSS, JavaScript, etc.) se definen en extensos documentos denominados especificaciones, publicados por organizaciones de estándares (como W3C (en-US), WHATWG, ECMA (en-US) o Khronos (en-US)) que definen con precisión cómo se supone que deben comportarse esas tecnologías.

El caso de CSS no es diferente: lo desarrolla un grupo del W3C llamado CSS Working Group. Este grupo está compuesto por representantes de proveedores de navegadores y otras compañías interesadas en CSS. También hay otras personas, conocidas como expertos invitados, que actúan como voces independientes y no están vinculados a ninguna organización.

\subsection{Agregar CSS a un documento}

Lo primero que se debe hacer es decirle al documento HTML que hay algunas reglas CSS que queremos que use. Hay tres formas diferentes de aplicar CSS a un documento HTML, sin embargo, por ahora, veremos la forma más habitual y útil de hacerlo: vincular el CSS desde el encabezado del documento.

Crea un archivo en la misma carpeta que tu documento HTML y guárdalo como styles.css. La extensión .css muestra que es un archivo CSS.

Para vincular styles.css a index.html, añade la siguiente línea en algún lugar dentro del <head> del documento HTML:

\begin{lstlisting}
<link rel="stylesheet" href="styles.css">
\end{lstlisting}

Este elemento <link> le dice al navegador que hay una hoja de estilo con el atributo rel y la ubicación de esa hoja de estilo como el valor del atributo href
\begin{remark}
	El atributo rel indica la relación del documento enlazado con el actual.
\end{remark}

Puedes determinar múltiples selectores a la vez, separándolos con una coma. Si queremos que todos los párrafos y todos los elementos de la lista sean verdes, el código se verá así:

\begin{lstlisting}
	p, li {
		color: green;
	}
\end{lstlisting}

\subsection{Añadir una clase}
Hasta ahora, hemos utilizado elementos cuyo nombre se basa en el nombre de elemento que reciben en HTML. Esto funciona siempre que se desee que todos los elementos de ese tipo tengan el mismo aspecto en el documento. La mayoría de las veces no es el caso, por lo que deberás encontrar una manera de seleccionar un subconjunto de los elementos sin que cambien los demás. La forma más común de hacer esto es añadir una clase al elemento HTML y determinarla.
\\
En tu documento HTML, añade al segundo elemento de la lista un atributo de clase. Debería verse así:
\begin{lstlisting}
<ul>
<li>Punto uno</li>
<li class = "special">Punto dos</li>
<li>Punto <em>tres</em></li>
</ul>
\end{lstlisting}
En tu CSS, puedes seleccionar una clase special creando un selector que comience con un carácter de punto final. Añade lo siguiente a tu archivo CSS:
\begin{lstlisting}
	.special {
		color: orange;
		font-weight: bold;
	}
\end{lstlisting}

Puedes aplicar la clase special a cualquier elemento de la página que desees que tenga el mismo aspecto que este elemento de lista. Por ejemplo, es posible que desees que el <span> del párrafo también sea naranja y en negrita. 

A veces verás reglas con un selector que enumera el selector de elementos HTML junto con la clase:

\begin{lstlisting}
	li.special {
		color: orange;
		font-weight: bold;
	}
\end{lstlisting}

Esta sintaxis significa «determina cualquier elemento li que tenga una clase special». Si hicieras esto, ya no podrías aplicar la clase a un elemento <span> u otro elemento simplemente añadiéndole la clase; tendrías que añadir ese elemento a la lista de selectores:

\begin{lstlisting}
	li.special,
	span.special {
		color: orange;
		font-weight: bold;
	}
\end{lstlisting}

\subsection{Dar formato según la ubicación en un documento}
Hay momentos en los que querrás que algo se vea diferente en función de dónde esté en el documento. Hay múltiples selectores que pueden hacerlo, pero por ahora veremos solo un par. En nuestro documento hay dos elementos <em>: uno dentro de un párrafo y el otro dentro de un elemento de la lista. Para seleccionar solo un <em> que esté anidado dentro de un elemento <li>, podemos usar un selector llamado combinador descendente, que simplemente toma la forma de un espacio entre otros dos selectores.

\begin{remark}
Combinador Css de descendiente: (espacio en blanco) o >>
\end{remark}

\begin{lstlisting}
	li em {
		color: rebeccapurple;
	}
\end{lstlisting}

Este selector separará cualquier elemento <em> que esté dentro de (un descendiente de) <li>. Entonces, en tu documento de ejemplo, deberías encontrar que el <em> del tercer elemento de la lista es morado, pero el que hay en el párrafo no ha cambiado.


Otra cosa que puedes probar es dar formato un párrafo que venga directamente a continuación de un título que esté en el mismo nivel de jerarquía en el HTML. Para hacerlo, coloca un + (un combinador hermano adyacente) entre los selectores.

\begin{lstlisting}
h1 + p {
	font-size: 200%;
}
\end{lstlisting}

\begin{lstlisting}
<h1>I am a level one heading</h1>

<p>This is a paragraph of text. In the text is a <span>span element</span> 
and also a <a href="http://example.com">link</a>.</p>

<p>This is the second paragraph. It contains an <em>emphasized</em> element.</p>

<ul>
<li>Item <span>one</span></li>
<li>Item two</li>
<li>Item <em>three</em></li>
</ul>
\end{lstlisting}

Salida:

\begin{figure}[H]
	\center
	\includegraphics[width=0.7\textwidth]{css1.png}
	\caption{Salida de formato según la ubicación}
	\label{fig:super}
\end{figure}

\subsection{Dar formato según el estado}

 Un ejemplo sencillo es el estilo de los enlaces. Cuando damos formato a un enlace, necesitamos seleccionar el elemento <a> (anclaje). Tiene diferentes estados dependiendo de si se ha visitado o no, se pasa por encima, o se presiona con el teclado o se hace clic (se activa). Puedes usar CSS para dar formato a estos diferentes estados. El CSS que encontrarás a continuación presenta en color rosa los enlaces que no se han visitado y en verde los que sí.
 
 \begin{lstlisting}
a:link {
	color: pink;
}

a:visited {
	color: green;
}
 \end{lstlisting}

Puedes cambiar la apariencia del enlace, por ejemplo, eliminando el subrayado, lo que se logra mediante la siguiente regla:

 \begin{lstlisting}
	a:hover {
		text-decoration: none;
	}
\end{lstlisting}

\subsection{Estilos en línea}
Los estilos en línea son declaraciones CSS que afectan a un solo elemento, contenido dentro de un atributo de style:
\begin{lstlisting}
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Mi experimento CSS</title>
</head>
<body>
<h1 style="color: blue;background-color: yellow;border: 1px solid black;">¡Hola mundo!</h1>
<p style="color:red;">Este es mi primer ejemplo de CSS</p>
</body>
</html>~
\end{lstlisting}

\begin{remark}
¡No hagas esto a menos que realmente tengas que hacerlo! Es realmente malo a la hora de realizar el mantenimiento 
\end{remark}

\subsection{Selectores}
No se puede hablar de CSS sin mencionar los selectores, de los cuales ya hemos descubierto varios tipos diferentes en la lección Empezar con el CSS. Un selector es, como determinamos, un elemento de nuestro documento HTML para aplicarle estilo. Si los estilos no se aplican correctamente, es probable que el selector no coincida con lo que crees que debería coincidir.

Cada regla CSS comienza con un selector o una lista de selectores que indican al navegador a qué elemento o elementos deben aplicarse dichas reglas. Todos los siguientes son ejemplos de selectores válidos o listas de selectores.

\begin{lstlisting}
h1
a:link
.manythings
#onething
*
.box p
.box p:first-child
h1, h2, .intro
\end{lstlisting}

\begin{figure}[H]
	\center
	\includegraphics[width=1\textwidth]{cheatsheet-css.png}
	\caption{Hoja de trucos CSS}
	\label{fig:super}
\end{figure}

\subsection{Especificidad}
A menudo habrá situaciones en las que dos selectores podrían determinar un mismo elemento HTML. Considera la siguiente hoja de estilo, en que definimos una regla con un selector p que establecerá los párrafos en color azul, y también una clase que establecerá los elementos seleccionados en color rojo.

\begin{lstlisting}
.special {
	color: red;
}

p {
	color: blue;
}
\end{lstlisting}

Digamos que en nuestro documento HTML hay un párrafo con una clase special. Ambas reglas podrían aplicarse. ¿Cuál ganará? ¿De qué color crees que será nuestro párrafo?

\begin{lstlisting}
<p class="special">¿De qué color soy?</p>
\end{lstlisting}

El lenguaje CSS tiene reglas para controlar cuál ganará en caso de colisión; reciben el nombre de cascada y especificidad. En el siguiente bloque de códigos hemos definido dos reglas para el selector p, pero el párrafo termina siendo de color azul. Esto se debe a que la declaración que lo establece en azul aparece más abajo en la hoja de estilo, y los estilos posteriores anulan a los anteriores. Así funciona la regla de la cascada.

\subsection{@rules}
Las @rules (leído "at-rules" en inglés) dan al CSS algunas instrucciones sobre cómo comportarse. Algunas @rules son simples, con el nombre de la regla y un valor. Por ejemplo, para importar una hoja de estilo adicional a tu hoja de estilo CSS principal, puedes usar @import:

\begin{lstlisting}
@import 'styles2.css';
\end{lstlisting}

Una de las @rules más comunes con las que te encontrarás es @media, que permite usar consultas a medios para aplicar CSS solo cuando se dan ciertas condiciones (por ejemplo, cuando la resolución de la pantalla supera un valor determinado o la anchura supera un valor concreto).

En el CSS que se muestra a continuación, tenemos una hoja de estilo que le da al elemento <body> un color de fondo rosado. Sin embargo, luego usamos @media para crear una sección de nuestra hoja de estilo que solo se aplicará en los navegadores con una ventana gráfica de más de 30em de ancho. Si el navegador es más ancho que 30em, el color de fondo será azul.

\begin{lstlisting}
body {
	background-color: pink;
}

@media (min-width: 30em) {
	body {
		background-color: blue;
	}
}
\end{lstlisting}

\subsection{Abreviaturas}
Algunas propiedades como font, background, padding, border y margin se llaman propiedades abreviadas. Esto se debe a que permiten establecer varios valores de propiedad en una sola línea, lo que ahorra tiempo y ordena el código.

Por ejemplo, esta línea:

\begin{lstlisting}
/* En propiedades abreviadas con 4 valores, como margin y padding (relleno), los valores se aplican
según el orden: arriba, derecha, abajo e izquierda (en sentido horario desde la parte superior). También hay otros
tipos de abreviaturas, como las propiedades abreviadas con 2 valores que establecen el relleno/margen,
arriba/abajo, y luego izquierda/derecha */
padding: 10px 15px 15px 5px;
\end{lstlisting}

Hace lo mismo que todas estas juntas:

\begin{lstlisting}
padding-top: 10px;
padding-right: 15px;
padding-bottom: 15px;
padding-left: 5px;
\end{lstlisting}

\subsection{¿Cómo funciona realmente el CSS?}

Cuando un navegador muestra un documento, ha de combinar el contenido con la información de estilo del documento. Procesa el documento en una serie de etapas, que enumeraremos a continuación. Ten en cuenta que este es un modelo muy simplificado de lo que sucede cuando un navegador carga una página web y que cada navegador gestiona el proceso de manera diferente. Pero esto es más o menos lo que sucede.

\begin{itemize}
	\item El navegador carga el HTML (por ejemplo, lo recibe de la red).
	\item Convierte el HTML en un DOM (Modelo de objetos del documento). El DOM representa el documento en la memoria del ordenador. Lo explicaremos más detalladamente en la sección siguiente.
	\item Entonces, el navegador va a buscar la mayor parte de los recursos vinculados al documento HTML, como las imágenes y los videos incrustados... ¡y también el CSS vinculado! JavaScript aparece un poco más adelante en el proceso, pero no vamos a hablar de ello aún para evitar complicar las cosas.
	\item El navegador analiza el CSS y ordena en diferentes «cubos» las diferentes reglas según el tipo de selector. Por ejemplo, elemento, clase, ID, y así sucesivamente. Para cada tipo de selector que encuentre, calcula qué reglas deben aplicarse y a qué nodos en el DOM se les aplica el estilo según corresponda (este paso intermedio se llama árbol de renderización).
	\item El árbol de renderización presenta la estructura en que los nodos deben aparecer después de aplicarle las reglas.
	\item En la pantalla se muestra el aspecto visual de la página (esta etapa se llama pintura).
	
	
\end{itemize}
El siguiente diagrama ofrece una visión sencilla de este proceso.

\begin{figure}[H]
	\center
	\includegraphics[width=1\textwidth]{rendering.png}
	\caption{Carga del css}
	\label{fig:super}
\end{figure}


\\
\url{https://developer.mozilla.org/es/docs/Learn/CSS/CSS_layout/Normal_Flow}
\url{https://developer.mozilla.org/es/docs/Learn/CSS/CSS_layout}

\subsection{Contenido desbordante}


El desbordamiento es lo que sucede cuando hay demasiado contenido para caber en un contenedor. En esta guía aprenderá qué es el desbordamiento y cómo gestionarlo.

Todo en CSS es una caja. Puede restringir el tamaño de estos cuadros asignando valores de ancho y alto (o tamaño en línea y tamaño de bloque). El desbordamiento ocurre cuando hay demasiado contenido para caber en una caja. CSS proporciona varias herramientas para administrar el desbordamiento. A medida que avance con el diseño de CSS y escriba CSS, encontrará más situaciones de desbordamiento.

CSS intenta evitar la "pérdida de datos"
Consideremos dos ejemplos que demuestran el comportamiento predeterminado de CSS cuando hay desbordamiento.

El primer ejemplo es una caja que ha sido restringida estableciendo una altura. Luego agregamos contenido que excede el espacio asignado. El contenido desborda el cuadro y cae en el párrafo siguiente.


\begin{figure}[H]
	\center
	\includegraphics[width=1\textwidth]{desbordamiento1.png}
	\caption{Ejemplo desbordamiento}
	\label{fig:super}
\end{figure}

El segundo ejemplo es una palabra en un cuadro. La caja se ha hecho demasiado pequeña para la palabra, por lo que se sale de la caja.

\begin{figure}[H]
	\center
	\includegraphics[width=1\textwidth]{desbordamiento2.png}
	\caption{Ejemplo desbordamiento}
	\label{fig:super}
\end{figure}

Siempre que sea posible, CSS no oculta el contenido. Esto provocaría la pérdida de datos. El problema con la pérdida de datos es que es posible que no lo notes. Es posible que los visitantes del sitio web no se den cuenta. Si el botón de enviar en un formulario desaparece y nadie puede completarlo, ¡esto podría ser un gran problema! En cambio, CSS se desborda de manera visible. Es más probable que vea que hay un problema. En el peor de los casos, un visitante del sitio le informará que el contenido se superpone.

La propiedad de desbordamiento es cómo tomas el control del desbordamiento de un elemento. Es la forma en que le indica al navegador cómo debe comportarse. El valor predeterminado de overflow es visible. Con este valor predeterminado, podemos ver el contenido cuando se desborda.

Para recortar el contenido cuando se desborda, puede establecer desbordamiento: oculto. Esto hace exactamente lo que dice: oculta el desbordamiento. Tenga en cuenta que esto puede hacer que algunos contenidos sean invisibles. Solo debe hacer esto si ocultar contenido no causará problemas.

\begin{lstlisting}
.box {
	border: 1px solid #333333;
	width: 200px;
	height: 100px;
	overflow: hidden;
}
\end{lstlisting}

\begin{figure}[H]
	\center
	\includegraphics[width=1\textwidth]{desbordamiento3.png}
	\caption{Ejemplo desbordamiento}
	\label{fig:super}
\end{figure}

Usando overflow: scroll, los navegadores con barras de desplazamiento visibles siempre las mostrarán, incluso si no hay suficiente contenido para desbordar.

\begin{lstlisting}
.box {
	overflow: scroll;
}
\end{lstlisting}

\begin{remark}
Para simplemente desplazarse en el eje y, puede usar la propiedad overflow-y, configurando overflow-y: scroll. y overflow-x para desplazarse en el eje de las x
\end{remark}

\subsection{Normal flow}

Los elementos en las páginas web se presentan de acuerdo con el flujo normal, hasta que hacemos algo que cambie eso. Esta sección explica las bases del flujo normal para aprender como cambiarlo.
\\
¿Cómo se presentan por defecto los elementos?
\\\\
En primer lugar, se toma de las cajas de cada uno de los elementos el contenido, luego se añade cualquier área de relleno, borde y margen alrededor de ellas; es el modelo de cajas que hemos visto antes.
\\
De manera predeterminada, el contenido de un elemento de nivel de bloque es el 100% del ancho de su elemento padre y su altura viene determinada por su contenido. Los elementos en línea tienen su altura y anchura determinados por su contenido. No puedes establecer el ancho o la altura de los elementos en línea, simplemente se ubican dentro del contenido de los elementos de nivel de bloque. Si deseas controlar el tamaño de un elemento en línea de esta manera, debes configurarlo para que se comporte como un elemento de nivel de bloque con display: block; (o incluso, display: inline-block;, que combina características de ambos).
\\
Esto explica los elementos individuales, pero ¿qué hay del modo como los elementos interactúan entre sí? El flujo de diseño normal (mencionado en el artículo de introducción al diseño) es el sistema mediante el cual los elementos se colocan en la ventana gráfica del navegador. De manera predeterminada, los elementos de nivel de bloque se presentan en la dirección del flujo del bloque, en función del modo de escritura de los padres (initial: horizontal-tb): cada uno aparecerá en una línea nueva debajo de la última, y estarán separados por cualquier margen que se establezca en ellos. Por lo tanto, en inglés, o en cualquier otro modo de escritura horizontal y de arriba a abajo, los elementos de nivel de bloque se disponen verticalmente.
\\
Los elementos en línea se comportan de manera diferente: no aparecen en líneas nuevas; en su lugar, se asientan en la misma línea entre sí y con cualquier contenido de texto adyacente (o envuelto), siempre que tengan espacio dentro del ancho del elemento de nivel de bloque primario. Si no hay espacio, el texto o los elementos que desborden bajarán a la línea siguiente.
\\
Si dos elementos adyacentes tienen algún margen configurado y los dos márgenes se tocan, se mantiene el mayor de los dos y el menor desaparece; esto se llama colapso del margen, y ya lo hemos visto antes.

\begin{figure}[H]
	\center
	\includegraphics[width=1\textwidth]{flujo1.png}
	\caption{Ejemplo Flujo normal}
	\label{fig:super}
\end{figure}


\subsubsection{Flexbox}

Flexbox es un método de diseño de página unidimensional para compaginar elementos en filas o columnas. Los elementos de contenido se ensanchan para rellenar el espacio adicional y se encogen para caber en espacios más pequeños. En este artículo expondremos todas sus características básicas.


\subsubsection{Frameworks CSS}

material ui GOD
ERICK JOEL DAMIAN CASIS18:17
bulma 
LUIS MAURICIO MATANGO MENDOZA18:17
next ui
HENRRY DAVID ALVARADO MALES18:17
Ant Design
material dashboard
prime ng
Prime React
Chakra UI



\subsubsection{Tailwind CSS}
\subsection{Javascript - ECMAScript}
\subsection{Typescript}
https://www.typescriptlang.org/cheatsheets

\subsection{CRUD}
\subsubsection{Entidades - DTOs}
\subsubsection{Servicios}
\subsubsection{Componentes}
\subsubsection{Input - Output}
\subsection{Temas}
\subsection{Menús}
\section{Ramificación GIT}

\section{Localización e Internacionalización}

\cite{w3}¿Qué significan los términos "internacionalización" y "localización" y cómo se relacionan?

Ofrecemos aquí algunas descripciones generales, de alto nivel, que reflejan el modo en que tendemos a utilizar estos términos en el sitio del W3C dedicado a la internacionalización.

\subsection{Localización}

Se entiende por localización la adaptación de un producto, una aplicación o el contenido de un documento con el fin de adecuarlos a las necesidades (lingüísticas, culturales u otras) de un mercado destinatario concreto (una "localidad" o "local" [locale]).

\begin{remark}
La palabra localización a veces se escribe "l10n", donde 10 es la cantidad de letras entre la ele y la ene.
\end{remark}


Aunque se la considera a menudo sinónimo de traducción de la interfaz de usuario y de la documentación, la localización suele ser un asunto considerablemente más complejo, que puede implicar la adaptación del contenido en relación con:

\begin{enumerate}
	\item formatos numéricos, de fecha y de hora;
	\item uso de símbolos de moneda;
	\item uso del teclado;
	\item algoritmos de comparación y ordenamiento;
	\item símbolos, iconos y colores;
	\item texto y gráficos que contengan referencias a objetos, acciones o ideas que, en una cultura dada, puedan ser objeto de mala interpretación o considerados ofensivos;
	\item diferentes exigencias legales;
	\item y muchas otras cuestiones.
\end{enumerate}

La localización puede requerir incluso una reelaboración exhaustiva de la lógica, el diseño visual o la presentación, si la forma de hacer negocios (por ejemplo, las normas contables) o el paradigma aceptado de aprendizaje (por ejemplo, énfasis en el individuo o en el grupo) en la localidad de destino difieren mucho en relación con la cultura originaria.

\subsection{Internacionalización}

Existen diferentes definiciones para la palabra internacionalización. La que damos aquí es una definición operativa de alto nivel para usar con los materiales de la Actividad de internacionalización del W3C. Algunas personas utilizan otros términos para referirse al mismo concepto, por ejemplo, "globalización".

La internacionalización es el diseño y desarrollo de un producto, una aplicación o el contenido de un documento de modo tal que permita una fácil localización con destino a audiencias de diferentes culturas, regiones o idiomas.
\begin{remark}
	La palabra internacionalización a veces se escribe "i18n", donde 18 es la cantidad de letras entre la i y la ene.
\end{remark}

La internacionalización generalmente implica:

\begin{enumerate}
	\item Un modo de diseño y desarrollo que elimine obstáculos a la localización o la distribución internacional. Esto incluye cuestiones tales como (entre otras) usar Unicode o asegurar, allí donde corresponda, un correcto tratamiento de las codificaciones de caracteres anticuadas; controlar la concatenación de cadenas; o evitar que la programación dependa de valores de cadenas pertenecientes a la interfaz de usuario.
	\item Habilitar características que tal vez no sean usadas hasta el momento de la localización. Por ejemplo, añadir en la DTD etiquetas para habilitar el texto bidireccional o la identificación de idiomas. O hacer la CSS compatible con texto vertical u otras características tipográficas ajenas al alfabeto latino.
	\item Preparar el código para hacer frente a las preferencias locales, regionales, lingüísticas o culturales. Por lo general, esto supone incorporar características y datos de localización predefinidos a partir de bibliotecas existentes o de las preferencias del usuario. Algunos ejemplos son: formatos de fecha y hora, calendarios locales, formatos y sistemas de números, ordenamiento y presentación de listas, uso de nombres personales y formas de tratamiento, etc.
	\item Separar del código o contenido fuente los elementos localizables, de modo que puedan cargarse o seleccionarse alternativas localizadas según determinen las preferencias internacionales del usuario.
\end{enumerate}

Obsérvese que esta lista no incluye necesariamente la localización del contenido, la aplicación o el producto hacia otro idioma; se trata más bien de prácticas de diseño y desarrollo que facilitan esa migración en el futuro, pero que también pueden tener una utilidad considerable aunque la localización jamás se produzca.

La internacionalización influye considerablemente en la facilidad de localización del producto. Obviamente, resulta mucho más difícil y demanda mucho más tiempo adaptar retrospectivamente un producto centrado en un idioma y cultura particulares que diseñarlo desde un primer momento con la intención de presentarlo mundialmente. (Piénsese en el Y2K y todo lo que demandó tratar de "deshacer" la opción por campos de fecha de dos caracteres, basada en el supuesto de que se interpretarían siempre como "19xx").

De modo que, en condiciones ideales, la internacionalización se da como un paso fundamental en el proceso de diseño y desarrollo, más que como un agregado posterior que, a menudo, puede implicar un difícil y costoso proceso de reingeniería.
